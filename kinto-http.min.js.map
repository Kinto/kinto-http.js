{"version":3,"file":"kinto-http.min.js","sources":["../node_modules/tslib/tslib.es6.js","../src/utils.ts","../src/errors.ts","../src/http.ts","../src/endpoints.ts","../src/requests.ts","../src/batch.ts","../node_modules/uuid/dist/esm-browser/rng.js","../node_modules/uuid/dist/esm-browser/bytesToUuid.js","../node_modules/uuid/dist/esm-browser/v4.js","../src/collection.ts","../src/bucket.ts","../src/index.ts","../src/base.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/**\n * Chunks an array into n pieces.\n *\n * @private\n * @param  {Array}  array\n * @param  {Number} n\n * @return {Array}\n */\nexport function partition<T>(array: T[], n: number): T[][] {\n  if (n <= 0) {\n    return [array];\n  }\n  return array.reduce<T[][]>((acc, x, i) => {\n    if (i === 0 || i % n === 0) {\n      acc.push([x]);\n    } else {\n      acc[acc.length - 1].push(x);\n    }\n    return acc;\n  }, []);\n}\n\n/**\n * Returns a Promise always resolving after the specified amount in milliseconds.\n *\n * @return Promise<void>\n */\nexport function delay(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\ninterface Entity {\n  id: string;\n}\n\n/**\n * Always returns a resource data object from the provided argument.\n *\n * @private\n * @param  {Object|String} resource\n * @return {Object}\n */\nexport function toDataBody<T extends Entity>(resource: T | string): Entity {\n  if (isObject(resource)) {\n    return resource as T;\n  }\n  if (typeof resource === \"string\") {\n    return { id: resource };\n  }\n  throw new Error(\"Invalid argument.\");\n}\n\n/**\n * Transforms an object into an URL query string, stripping out any undefined\n * values.\n *\n * @param  {Object} obj\n * @return {String}\n */\nexport function qsify(obj: { [key: string]: any }): string {\n  const encode = (v: any): string =>\n    encodeURIComponent(typeof v === \"boolean\" ? String(v) : v);\n  const stripped = cleanUndefinedProperties(obj);\n  return Object.keys(stripped)\n    .map((k) => {\n      const ks = encode(k) + \"=\";\n      if (Array.isArray(stripped[k])) {\n        return ks + stripped[k].map((v: any) => encode(v)).join(\",\");\n      } else {\n        return ks + encode(stripped[k]);\n      }\n    })\n    .join(\"&\");\n}\n\n/**\n * Checks if a version is within the provided range.\n *\n * @param  {String} version    The version to check.\n * @param  {String} minVersion The minimum supported version (inclusive).\n * @param  {String} maxVersion The minimum supported version (exclusive).\n * @throws {Error} If the version is outside of the provided range.\n */\nexport function checkVersion(\n  version: string,\n  minVersion: string,\n  maxVersion: string\n): void {\n  const extract = (str: string): number[] =>\n    str.split(\".\").map((x) => parseInt(x, 10));\n  const [verMajor, verMinor] = extract(version);\n  const [minMajor, minMinor] = extract(minVersion);\n  const [maxMajor, maxMinor] = extract(maxVersion);\n  const checks = [\n    verMajor < minMajor,\n    verMajor === minMajor && verMinor < minMinor,\n    verMajor > maxMajor,\n    verMajor === maxMajor && verMinor >= maxMinor,\n  ];\n  if (checks.some((x) => x)) {\n    throw new Error(\n      `Version ${version} doesn't satisfy ${minVersion} <= x < ${maxVersion}`\n    );\n  }\n}\n\ntype DecoratorReturn = (\n  target: any,\n  key: string,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => any>\n) => {\n  configurable: boolean;\n  get(): (...args: any) => Promise<any>;\n};\n\n/**\n * Generates a decorator function ensuring a version check is performed against\n * the provided requirements before executing it.\n *\n * @param  {String} min The required min version (inclusive).\n * @param  {String} max The required max version (inclusive).\n * @return {Function}\n */\nexport function support(min: string, max: string): DecoratorReturn {\n  return function (\n    // @ts-ignore\n    target: any,\n    key: string,\n    descriptor: TypedPropertyDescriptor<(...args: any[]) => any>\n  ) {\n    const fn = descriptor.value;\n    return {\n      configurable: true,\n      get() {\n        const wrappedMethod = (...args: any): Promise<any> => {\n          // \"this\" is the current instance which its method is decorated.\n          const client = (this as any).client ? (this as any).client : this;\n          return client\n            .fetchHTTPApiVersion()\n            .then((version: string) => checkVersion(version, min, max))\n            .then(() => fn!.apply(this, args));\n        };\n        Object.defineProperty(this, key, {\n          value: wrappedMethod,\n          configurable: true,\n          writable: true,\n        });\n        return wrappedMethod;\n      },\n    };\n  };\n}\n\n/**\n * Generates a decorator function ensuring that the specified capabilities are\n * available on the server before executing it.\n *\n * @param  {Array<String>} capabilities The required capabilities.\n * @return {Function}\n */\nexport function capable(capabilities: string[]): DecoratorReturn {\n  return function (\n    // @ts-ignore\n    target: any,\n    key: string,\n    descriptor: TypedPropertyDescriptor<(...args: any[]) => any>\n  ) {\n    const fn = descriptor.value;\n    return {\n      configurable: true,\n      get() {\n        const wrappedMethod = (...args: any): Promise<any> => {\n          // \"this\" is the current instance which its method is decorated.\n          const client = (this as any).client ? (this as any).client : this;\n          return client\n            .fetchServerCapabilities()\n            .then((available: string[]) => {\n              const missing = capabilities.filter((c) => !(c in available));\n              if (missing.length > 0) {\n                const missingStr = missing.join(\", \");\n                throw new Error(\n                  `Required capabilities ${missingStr} not present on server`\n                );\n              }\n            })\n            .then(() => fn!.apply(this, args));\n        };\n        Object.defineProperty(this, key, {\n          value: wrappedMethod,\n          configurable: true,\n          writable: true,\n        });\n        return wrappedMethod;\n      },\n    };\n  };\n}\n\n/**\n * Generates a decorator function ensuring an operation is not performed from\n * within a batch request.\n *\n * @param  {String} message The error message to throw.\n * @return {Function}\n */\nexport function nobatch(message: string): DecoratorReturn {\n  return function (\n    // @ts-ignore\n    target: any,\n    key: string,\n    descriptor: TypedPropertyDescriptor<(...args: any[]) => any>\n  ) {\n    const fn = descriptor.value;\n    return {\n      configurable: true,\n      get() {\n        const wrappedMethod = (...args: any): any => {\n          // \"this\" is the current instance which its method is decorated.\n          if ((this as any)._isBatch) {\n            throw new Error(message);\n          }\n          return fn!.apply(this, args);\n        };\n        Object.defineProperty(this, key, {\n          value: wrappedMethod,\n          configurable: true,\n          writable: true,\n        });\n        return wrappedMethod;\n      },\n    };\n  };\n}\n\n/**\n * Returns true if the specified value is an object (i.e. not an array nor null).\n * @param  {Object} thing The value to inspect.\n * @return {bool}\n */\nexport function isObject(thing: unknown): boolean {\n  return typeof thing === \"object\" && thing !== null && !Array.isArray(thing);\n}\n\ninterface TypedDataURL {\n  type: string;\n  base64: string;\n  [key: string]: string;\n}\n\n/**\n * Parses a data url.\n * @param  {String} dataURL The data url.\n * @return {Object}\n */\nexport function parseDataURL(dataURL: string): TypedDataURL {\n  const regex = /^data:(.*);base64,(.*)/;\n  const match = dataURL.match(regex);\n  if (!match) {\n    throw new Error(`Invalid data-url: ${String(dataURL).substr(0, 32)}...`);\n  }\n  const props = match[1];\n  const base64 = match[2];\n  const [type, ...rawParams] = props.split(\";\");\n  const params = rawParams.reduce<{ [key: string]: string }>((acc, param) => {\n    const [key, value] = param.split(\"=\");\n    return { ...acc, [key]: value };\n  }, {});\n  return { ...params, type, base64 };\n}\n\n/**\n * Extracts file information from a data url.\n * @param  {String} dataURL The data url.\n * @return {Object}\n */\nexport function extractFileInfo(\n  dataURL: string\n): {\n  blob: Blob;\n  name: string;\n} {\n  const { name, type, base64 } = parseDataURL(dataURL);\n  const binary = atob(base64);\n  const array = [];\n  for (let i = 0; i < binary.length; i++) {\n    array.push(binary.charCodeAt(i));\n  }\n  const blob = new Blob([new Uint8Array(array)], { type });\n\n  return { blob, name };\n}\n\n/**\n * Creates a FormData instance from a data url and an existing JSON response\n * body.\n * @param  {String} dataURL            The data url.\n * @param  {Object} body               The response body.\n * @param  {Object} [options={}]       The options object.\n * @param  {Object} [options.filename] Force attachment file name.\n * @return {FormData}\n */\nexport function createFormData(\n  dataURL: string,\n  body: { [key: string]: any },\n  options: { filename?: string } = {}\n): FormData {\n  const { filename = \"untitled\" } = options;\n  const { blob, name } = extractFileInfo(dataURL);\n  const formData = new FormData();\n  formData.append(\"attachment\", blob, name || filename);\n  for (const property in body) {\n    if (typeof body[property] !== \"undefined\") {\n      formData.append(property, JSON.stringify(body[property]));\n    }\n  }\n  return formData;\n}\n\n/**\n * Clones an object with all its undefined keys removed.\n * @private\n */\nexport function cleanUndefinedProperties(obj: {\n  [key: string]: any;\n}): {\n  [key: string]: any;\n} {\n  const result: { [key: string]: any } = {};\n  for (const key in obj) {\n    if (typeof obj[key] !== \"undefined\") {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\n/**\n * Handle common query parameters for Kinto requests.\n *\n * @param  {String}  [path]  The endpoint base path.\n * @param  {Array}   [options.fields]    Fields to limit the\n *   request to.\n * @param  {Object}  [options.query={}]  Additional query arguments.\n */\nexport function addEndpointOptions(\n  path: string,\n  options: { fields?: string[]; query?: { [key: string]: string } } = {}\n): string {\n  const query: { [key: string]: any } = { ...options.query };\n  if (options.fields) {\n    query._fields = options.fields;\n  }\n  const queryString = qsify(query);\n  if (queryString) {\n    return path + \"?\" + queryString;\n  }\n  return path;\n}\n\n/**\n * Replace authorization header with an obscured version\n */\nexport function obscureAuthorizationHeader(\n  headers: HeadersInit\n): {\n  [key: string]: string;\n} {\n  const h = new Headers(headers);\n  if (h.has(\"authorization\")) {\n    h.set(\"authorization\", \"**** (suppressed)\");\n  }\n\n  const obscuredHeaders: { [key: string]: string } = {};\n  for (const [header, value] of h.entries()) {\n    obscuredHeaders[header] = value;\n  }\n\n  return obscuredHeaders;\n}\n","/**\n * Kinto server error code descriptors.\n */\nconst ERROR_CODES = {\n  104: \"Missing Authorization Token\",\n  105: \"Invalid Authorization Token\",\n  106: \"Request body was not valid JSON\",\n  107: \"Invalid request parameter\",\n  108: \"Missing request parameter\",\n  109: \"Invalid posted data\",\n  110: \"Invalid Token / id\",\n  111: \"Missing Token / id\",\n  112: \"Content-Length header was not provided\",\n  113: \"Request body too large\",\n  114: \"Resource was created, updated or deleted meanwhile\",\n  115: \"Method not allowed on this end point (hint: server may be readonly)\",\n  116: \"Requested version not available on this server\",\n  117: \"Client has sent too many requests\",\n  121: \"Resource access is forbidden for this user\",\n  122: \"Another resource violates constraint\",\n  201: \"Service Temporary unavailable due to high load\",\n  202: \"Service deprecated\",\n  999: \"Internal Server Error\",\n};\n\nexport default ERROR_CODES;\n\nclass NetworkTimeoutError extends Error {\n  public url: string;\n  public options: Object;\n\n  constructor(url: string, options: Object) {\n    super(\n      `Timeout while trying to access ${url} with ${JSON.stringify(options)}`\n    );\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, NetworkTimeoutError);\n    }\n\n    this.url = url;\n    this.options = options;\n  }\n}\n\nclass UnparseableResponseError extends Error {\n  public status: number;\n  public response: Response;\n  public stack?: string;\n  public error: Error;\n\n  constructor(response: Response, body: string, error: Error) {\n    const { status } = response;\n\n    super(\n      `Response from server unparseable (HTTP ${\n        status || 0\n      }; ${error}): ${body}`\n    );\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, UnparseableResponseError);\n    }\n\n    this.status = status;\n    this.response = response;\n    this.stack = error.stack;\n    this.error = error;\n  }\n}\n\nexport interface ServerResponseObject {\n  code: number;\n  errno: keyof typeof ERROR_CODES;\n  error: string;\n  message: string;\n  info: string;\n  details: unknown;\n}\n\n/**\n * \"Error\" subclass representing a >=400 response from the server.\n *\n * Whether or not this is an error depends on your application.\n *\n * The `json` field can be undefined if the server responded with an\n * empty response body. This shouldn't generally happen. Most \"bad\"\n * responses come with a JSON error description, or (if they're\n * fronted by a CDN or nginx or something) occasionally non-JSON\n * responses (which become UnparseableResponseErrors, above).\n */\nclass ServerResponse extends Error {\n  public response: Response;\n  public data?: ServerResponseObject;\n\n  constructor(response: Response, json?: ServerResponseObject) {\n    const { status } = response;\n    let { statusText } = response;\n    let errnoMsg;\n\n    if (json) {\n      // Try to fill in information from the JSON error.\n      statusText = json.error || statusText;\n\n      // Take errnoMsg from either ERROR_CODES or json.message.\n      if (json.errno && json.errno in ERROR_CODES) {\n        errnoMsg = ERROR_CODES[json.errno];\n      } else if (json.message) {\n        errnoMsg = json.message;\n      }\n\n      // If we had both ERROR_CODES and json.message, and they differ,\n      // combine them.\n      if (errnoMsg && json.message && json.message !== errnoMsg) {\n        errnoMsg += ` (${json.message})`;\n      }\n    }\n\n    let message = `HTTP ${status} ${statusText}`;\n    if (errnoMsg) {\n      message += `: ${errnoMsg}`;\n    }\n\n    super(message.trim());\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ServerResponse);\n    }\n\n    this.response = response;\n    this.data = json;\n  }\n}\n\nexport { NetworkTimeoutError, ServerResponse, UnparseableResponseError };\n","import { delay, obscureAuthorizationHeader } from \"./utils\";\nimport {\n  NetworkTimeoutError,\n  ServerResponse,\n  UnparseableResponseError,\n  ServerResponseObject,\n} from \"./errors\";\nimport { Emitter } from \"./types\";\n\ninterface HttpOptions {\n  timeout?: number | null;\n  requestMode?: RequestMode;\n}\n\ninterface RequestOptions {\n  retry: number;\n}\n\nexport interface HttpResponse<T> {\n  status: number;\n  json: T;\n  headers: Headers;\n}\n\n/**\n * Enhanced HTTP client for the Kinto protocol.\n * @private\n */\nexport default class HTTP {\n  /**\n   * Default HTTP request headers applied to each outgoing request.\n   *\n   * @type {Object}\n   */\n  static get DEFAULT_REQUEST_HEADERS(): Record<string, string> {\n    return {\n      Accept: \"application/json\",\n      \"Content-Type\": \"application/json\",\n    };\n  }\n\n  /**\n   * Default options.\n   *\n   * @type {Object}\n   */\n  static get defaultOptions(): HttpOptions {\n    return { timeout: null, requestMode: \"cors\" };\n  }\n\n  public events?: Emitter;\n  public requestMode: RequestMode;\n  public timeout: number;\n\n  /**\n   * Constructor.\n   *\n   * @param {EventEmitter} events                       The event handler.\n   * @param {Object}       [options={}}                 The options object.\n   * @param {Number}       [options.timeout=null]       The request timeout in ms, if any (default: `null`).\n   * @param {String}       [options.requestMode=\"cors\"] The HTTP request mode (default: `\"cors\"`).\n   */\n  constructor(events?: Emitter, options: HttpOptions = {}) {\n    // public properties\n    /**\n     * The event emitter instance.\n     * @type {EventEmitter}\n     */\n    this.events = events;\n\n    /**\n     * The request mode.\n     * @see  https://fetch.spec.whatwg.org/#requestmode\n     * @type {String}\n     */\n    this.requestMode = options.requestMode || HTTP.defaultOptions.requestMode!;\n\n    /**\n     * The request timeout.\n     * @type {Number}\n     */\n    this.timeout = options.timeout || HTTP.defaultOptions.timeout!;\n  }\n\n  /**\n   * @private\n   */\n  timedFetch(url: string, options: RequestInit): Promise<Response> {\n    let hasTimedout = false;\n    return new Promise((resolve, reject) => {\n      // Detect if a request has timed out.\n      let _timeoutId: ReturnType<typeof setTimeout>;\n      if (this.timeout) {\n        _timeoutId = setTimeout(() => {\n          hasTimedout = true;\n          if (options && options.headers) {\n            options = {\n              ...options,\n              headers: obscureAuthorizationHeader(options.headers),\n            };\n          }\n          reject(new NetworkTimeoutError(url, options));\n        }, this.timeout);\n      }\n      function proceedWithHandler(fn: (arg: any) => void): (arg: any) => void {\n        return (arg: any) => {\n          if (!hasTimedout) {\n            if (_timeoutId) {\n              clearTimeout(_timeoutId);\n            }\n            fn(arg);\n          }\n        };\n      }\n      fetch(url, options)\n        .then(proceedWithHandler(resolve))\n        .catch(proceedWithHandler(reject));\n    });\n  }\n\n  /**\n   * @private\n   */\n  async processResponse<T>(response: Response): Promise<HttpResponse<T>> {\n    const { status, headers } = response;\n    const text = await response.text();\n    // Check if we have a body; if so parse it as JSON.\n    let json: unknown;\n    if (text.length !== 0) {\n      try {\n        json = JSON.parse(text);\n      } catch (err) {\n        throw new UnparseableResponseError(response, text, err);\n      }\n    }\n    if (status >= 400) {\n      throw new ServerResponse(response, json as ServerResponseObject);\n    }\n    return { status, json: json as T, headers };\n  }\n\n  /**\n   * @private\n   */\n  async retry<T>(\n    url: string,\n    retryAfter: number,\n    request: RequestInit,\n    options: RequestOptions\n  ): Promise<HttpResponse<T>> {\n    await delay(retryAfter);\n    return this.request<T>(url, request, {\n      ...options,\n      retry: options.retry - 1,\n    });\n  }\n\n  /**\n   * Performs an HTTP request to the Kinto server.\n   *\n   * Resolves with an objet containing the following HTTP response properties:\n   * - `{Number}  status`  The HTTP status code.\n   * - `{Object}  json`    The JSON response body.\n   * - `{Headers} headers` The response headers object; see the ES6 fetch() spec.\n   *\n   * @param  {String} url               The URL.\n   * @param  {Object} [request={}]      The request object, passed to\n   *     fetch() as its options object.\n   * @param  {Object} [request.headers] The request headers object (default: {})\n   * @param  {Object} [options={}]      Options for making the\n   *     request\n   * @param  {Number} [options.retry]   Number of retries (default: 0)\n   * @return {Promise}\n   */\n  async request<T>(\n    url: string,\n    request: RequestInit = { headers: {} },\n    options: RequestOptions = { retry: 0 }\n  ): Promise<HttpResponse<T>> {\n    // Ensure default request headers are always set\n    request.headers = { ...HTTP.DEFAULT_REQUEST_HEADERS, ...request.headers };\n    // If a multipart body is provided, remove any custom Content-Type header as\n    // the fetch() implementation will add the correct one for us.\n    if (request.body && request.body instanceof FormData) {\n      if (request.headers instanceof Headers) {\n        request.headers.delete(\"Content-Type\");\n      } else if (!Array.isArray(request.headers)) {\n        delete request.headers[\"Content-Type\"];\n      }\n    }\n    request.mode = this.requestMode;\n\n    const response = await this.timedFetch(url, request);\n    const { headers } = response;\n\n    this._checkForDeprecationHeader(headers);\n    this._checkForBackoffHeader(headers);\n\n    // Check if the server summons the client to retry after a while.\n    const retryAfter = this._checkForRetryAfterHeader(headers);\n    // If number of allowed of retries is not exhausted, retry the same request.\n    if (retryAfter && options.retry > 0) {\n      return this.retry<T>(url, retryAfter, request, options);\n    } else {\n      return this.processResponse<T>(response);\n    }\n  }\n\n  _checkForDeprecationHeader(headers: Headers): void {\n    const alertHeader = headers.get(\"Alert\");\n    if (!alertHeader) {\n      return;\n    }\n    let alert;\n    try {\n      alert = JSON.parse(alertHeader);\n    } catch (err) {\n      console.warn(\"Unable to parse Alert header message\", alertHeader);\n      return;\n    }\n    console.warn(alert.message, alert.url);\n    if (this.events) {\n      this.events.emit(\"deprecated\", alert);\n    }\n  }\n\n  _checkForBackoffHeader(headers: Headers): void {\n    let backoffMs;\n    const backoffHeader = headers.get(\"Backoff\");\n    const backoffSeconds = backoffHeader ? parseInt(backoffHeader, 10) : 0;\n    if (backoffSeconds > 0) {\n      backoffMs = new Date().getTime() + backoffSeconds * 1000;\n    } else {\n      backoffMs = 0;\n    }\n    if (this.events) {\n      this.events.emit(\"backoff\", backoffMs);\n    }\n  }\n\n  _checkForRetryAfterHeader(headers: Headers): number | undefined {\n    const retryAfter = headers.get(\"Retry-After\");\n    if (!retryAfter) {\n      return;\n    }\n    const delay = parseInt(retryAfter, 10) * 1000;\n    const tryAgainAfter = new Date().getTime() + delay;\n    if (this.events) {\n      this.events.emit(\"retry-after\", tryAgainAfter);\n    }\n    return delay;\n  }\n}\n","/**\n * Endpoints templates.\n * @type {Object}\n */\nconst ENDPOINTS = {\n  root: () => \"/\",\n  batch: () => \"/batch\",\n  permissions: () => \"/permissions\",\n  bucket: (bucket?: string) => \"/buckets\" + (bucket ? `/${bucket}` : \"\"),\n  history: (bucket: string) => `${ENDPOINTS.bucket(bucket)}/history`,\n  collection: (bucket: string, coll?: string) =>\n    `${ENDPOINTS.bucket(bucket)}/collections` + (coll ? `/${coll}` : \"\"),\n  group: (bucket: string, group?: string) =>\n    `${ENDPOINTS.bucket(bucket)}/groups` + (group ? `/${group}` : \"\"),\n  record: (bucket: string, coll: string, id?: string) =>\n    `${ENDPOINTS.collection(bucket, coll)}/records` + (id ? `/${id}` : \"\"),\n  attachment: (bucket: string, coll: string, id: string) =>\n    `${ENDPOINTS.record(bucket, coll, id)}/attachment`,\n};\n\nexport default ENDPOINTS;\n","import { KintoRequest, HttpMethod, Permission } from \"./types\";\nimport { createFormData } from \"./utils\";\n\ninterface RequestOptions {\n  safe?: boolean;\n  headers?: Headers | Record<string, string> | string[][];\n  method?: HttpMethod;\n  gzipped?: boolean | null;\n  last_modified?: number;\n  patch?: boolean;\n}\ntype AddAttachmentRequestOptions = RequestOptions & {\n  last_modified?: number;\n  filename?: string;\n};\n\ntype RequestBody = {\n  data?: any;\n  permissions?: Partial<Record<Permission, string[]>>;\n};\ninterface RecordRequestBody extends RequestBody {\n  data?: { id?: string; last_modified?: number; [key: string]: any };\n}\n\nconst requestDefaults: RequestOptions = {\n  safe: false,\n  // check if we should set default content type here\n  headers: {},\n  patch: false,\n};\n\n/**\n * @private\n */\nfunction safeHeader(\n  safe?: boolean,\n  last_modified?: number\n): Record<string, string> {\n  if (!safe) {\n    return {};\n  }\n  if (last_modified) {\n    return { \"If-Match\": `\"${last_modified}\"` };\n  }\n  return { \"If-None-Match\": \"*\" };\n}\n\n/**\n * @private\n */\nexport function createRequest(\n  path: string,\n  { data, permissions }: RequestBody,\n  options: RequestOptions = {}\n): KintoRequest {\n  const { headers, safe } = {\n    ...requestDefaults,\n    ...options,\n  };\n  const method = options.method || (data && data.id) ? \"PUT\" : \"POST\";\n  return {\n    method,\n    path,\n    headers: { ...headers, ...safeHeader(safe) },\n    body: { data, permissions },\n  };\n}\n\n/**\n * @private\n */\nexport function updateRequest(\n  path: string,\n  { data, permissions }: RecordRequestBody,\n  options: RequestOptions = {}\n): KintoRequest {\n  const { headers, safe, patch } = { ...requestDefaults, ...options };\n  const { last_modified } = { ...data, ...options };\n\n  const hasNoData =\n    data &&\n    Object.keys(data).filter((k) => k !== \"id\" && k !== \"last_modified\")\n      .length === 0;\n  if (hasNoData) {\n    data = undefined;\n  }\n\n  return {\n    method: patch ? \"PATCH\" : \"PUT\",\n    path,\n    headers: { ...headers, ...safeHeader(safe, last_modified) },\n    body: { data, permissions },\n  };\n}\n\n/**\n * @private\n */\nexport function jsonPatchPermissionsRequest(\n  path: string,\n  permissions: { [key in Permission]?: string[] },\n  opType: string,\n  options: RequestOptions = {}\n): KintoRequest {\n  const { headers, safe, last_modified } = { ...requestDefaults, ...options };\n\n  const ops = [];\n\n  for (const [type, principals] of Object.entries(permissions)) {\n    if (principals) {\n      for (const principal of principals) {\n        ops.push({\n          op: opType,\n          path: `/permissions/${type}/${principal}`,\n        });\n      }\n    }\n  }\n\n  return {\n    method: \"PATCH\",\n    path,\n    headers: {\n      ...headers,\n      ...safeHeader(safe, last_modified),\n      \"Content-Type\": \"application/json-patch+json\",\n    },\n    body: ops,\n  };\n}\n\n/**\n * @private\n */\nexport function deleteRequest(\n  path: string,\n  options: RequestOptions = {}\n): KintoRequest {\n  const { headers, safe, last_modified } = {\n    ...requestDefaults,\n    ...options,\n  };\n  if (safe && !last_modified) {\n    throw new Error(\"Safe concurrency check requires a last_modified value.\");\n  }\n  return {\n    method: \"DELETE\",\n    path,\n    headers: { ...headers, ...safeHeader(safe, last_modified) },\n  };\n}\n\n/**\n * @private\n */\nexport function addAttachmentRequest(\n  path: string,\n  dataURI: string,\n  { data, permissions }: RecordRequestBody = {},\n  options: AddAttachmentRequestOptions = {}\n): KintoRequest {\n  const { headers, safe, gzipped } = { ...requestDefaults, ...options };\n  const { last_modified } = { ...data, ...options };\n\n  const body = { data, permissions };\n  const formData = createFormData(dataURI, body, options);\n\n  const customPath = `${path}${\n    gzipped !== null ? \"?gzipped=\" + (gzipped ? \"true\" : \"false\") : \"\"\n  }`;\n\n  return {\n    method: \"POST\",\n    path: customPath,\n    headers: { ...headers, ...safeHeader(safe, last_modified) },\n    body: formData,\n  };\n}\n","import { KintoRequest } from \"./types\";\n\ninterface ConflictRecord {\n  last_modified: number;\n  id: string;\n}\n\ninterface ConflictResponse {\n  existing: ConflictRecord;\n}\n\ninterface ResponseBody {\n  data?: unknown;\n  details?: ConflictResponse;\n  code?: number;\n  errno?: number;\n  error?: string;\n  message?: string;\n  info?: string;\n}\n\ninterface ErrorResponse {\n  path: string;\n  sent: KintoRequest;\n  error: ResponseBody;\n}\n\nexport interface AggregateResponse {\n  errors: ErrorResponse[];\n  published: ResponseBody[];\n  conflicts: any[];\n  skipped: any[];\n}\n\nexport interface KintoBatchResponse {\n  status: number;\n  path: string;\n  body: ResponseBody;\n  headers: { [key: string]: string };\n}\n\n/**\n * Exports batch responses as a result object.\n *\n * @private\n * @param  {Array} responses The batch subrequest responses.\n * @param  {Array} requests  The initial issued requests.\n * @return {Object}\n */\nexport function aggregate(\n  responses: KintoBatchResponse[] = [],\n  requests: KintoRequest[] = []\n): AggregateResponse {\n  if (responses.length !== requests.length) {\n    throw new Error(\"Responses length should match requests one.\");\n  }\n  const results: AggregateResponse = {\n    errors: [],\n    published: [],\n    conflicts: [],\n    skipped: [],\n  };\n  return responses.reduce((acc, response, index) => {\n    const { status } = response;\n    const request = requests[index];\n    if (status >= 200 && status < 400) {\n      acc.published.push(response.body);\n    } else if (status === 404) {\n      // Extract the id manually from request path while waiting for Kinto/kinto#818\n      const regex = /(buckets|groups|collections|records)\\/([^/]+)$/;\n      const extracts = request.path.match(regex);\n      const id = extracts && extracts.length === 3 ? extracts[2] : undefined;\n      acc.skipped.push({\n        id,\n        path: request.path,\n        error: response.body,\n      });\n    } else if (status === 412) {\n      acc.conflicts.push({\n        // XXX: specifying the type is probably superfluous\n        type: \"outgoing\",\n        local: request.body,\n        remote:\n          (response.body.details && response.body.details.existing) || null,\n      });\n    } else {\n      acc.errors.push({\n        path: request.path,\n        sent: request,\n        error: response.body,\n      });\n    }\n    return acc;\n  }, results);\n}\n","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n// find the complete implementation of crypto (msCrypto) on IE11.\nvar getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);\nvar rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\nexport default function rng() {\n  if (!getRandomValues) {\n    throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n  }\n\n  return getRandomValues(rnds8);\n}","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n\n  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');\n}\n\nexport default bytesToUuid;","import rng from './rng.js';\nimport bytesToUuid from './bytesToUuid.js';\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof options == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nexport default v4;","import { v4 as uuid } from \"uuid\";\n\nimport { capable, toDataBody, isObject } from \"./utils\";\nimport * as requests from \"./requests\";\nimport KintoClientBase, { PaginatedListParams, PaginationResult } from \"./base\";\nimport Bucket from \"./bucket\";\nimport {\n  KintoRequest,\n  Permission,\n  KintoResponse,\n  KintoIdObject,\n  KintoObject,\n  Attachment,\n  HistoryEntry,\n  OperationResponse,\n  MappableObject,\n} from \"./types\";\nimport { HttpResponse } from \"./http\";\nimport { AggregateResponse } from \"./batch\";\n\nexport interface CollectionOptions {\n  headers?: Record<string, string>;\n  safe?: boolean;\n  retry?: number;\n}\n\n/**\n * Abstract representation of a selected collection.\n *\n */\nexport default class Collection {\n  public client: KintoClientBase;\n  private bucket: Bucket;\n  public name: string;\n  private _endpoints: KintoClientBase[\"endpoints\"];\n  private _retry: number;\n  private _safe: boolean;\n  private _headers: Record<string, string>;\n\n  /**\n   * Constructor.\n   *\n   * @param  {KintoClient}  client            The client instance.\n   * @param  {Bucket}       bucket            The bucket instance.\n   * @param  {String}       name              The collection name.\n   * @param  {Object}       [options={}]      The options object.\n   * @param  {Object}       [options.headers] The headers object option.\n   * @param  {Boolean}      [options.safe]    The safe option.\n   * @param  {Number}       [options.retry]   The retry option.\n   * @param  {Boolean}      [options.batch]   (Private) Whether this\n   *     Collection is operating as part of a batch.\n   */\n  constructor(\n    client: KintoClientBase,\n    bucket: Bucket,\n    name: string,\n    options: CollectionOptions = {}\n  ) {\n    /**\n     * @ignore\n     */\n    this.client = client;\n    /**\n     * @ignore\n     */\n    this.bucket = bucket;\n    /**\n     * The collection name.\n     * @type {String}\n     */\n    this.name = name;\n\n    this._endpoints = client.endpoints;\n\n    /**\n     * @ignore\n     */\n    this._retry = options.retry || 0;\n    this._safe = !!options.safe;\n    // FIXME: This is kind of ugly; shouldn't the bucket be responsible\n    // for doing the merge?\n    this._headers = {\n      ...this.bucket.headers,\n      ...options.headers,\n    };\n  }\n\n  /**\n   * Get the value of \"headers\" for a given request, merging the\n   * per-request headers with our own \"default\" headers.\n   *\n   * @private\n   */\n  private _getHeaders(options: {\n    headers?: Record<string, string>;\n  }): Record<string, string> {\n    return {\n      ...this._headers,\n      ...options.headers,\n    };\n  }\n\n  /**\n   * Get the value of \"safe\" for a given request, using the\n   * per-request option if present or falling back to our default\n   * otherwise.\n   *\n   * @private\n   * @param {Object} options The options for a request.\n   * @returns {Boolean}\n   */\n  private _getSafe(options: { safe?: boolean }): boolean {\n    return { safe: this._safe, ...options }.safe;\n  }\n\n  /**\n   * As _getSafe, but for \"retry\".\n   *\n   * @private\n   */\n  private _getRetry(options: { retry?: number }): number {\n    return { retry: this._retry, ...options }.retry;\n  }\n\n  /**\n   * Retrieves the total number of records in this collection.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Number, Error>}\n   */\n  async getTotalRecords(\n    options: { headers?: Record<string, string>; retry?: number } = {}\n  ): Promise<number> {\n    const path = this._endpoints.record(this.bucket.name, this.name);\n    const request: KintoRequest = {\n      headers: this._getHeaders(options),\n      path,\n      method: \"HEAD\",\n    };\n    const { headers } = await this.client.execute(request, {\n      raw: true,\n      retry: this._getRetry(options),\n    });\n    return parseInt(headers.get(\"Total-Records\"), 10);\n  }\n\n  /**\n   * Retrieves the ETag of the records list, for use with the `since` filtering option.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<String, Error>}\n   */\n  async getRecordsTimestamp(\n    options: { headers?: Record<string, string>; retry?: number } = {}\n  ): Promise<string | null> {\n    const path = this._endpoints.record(this.bucket.name, this.name);\n    const request: KintoRequest = {\n      headers: this._getHeaders(options),\n      path,\n      method: \"HEAD\",\n    };\n    const { headers } =\n      (await this.client.execute(request, {\n        raw: true,\n        retry: this._getRetry(options),\n      })) as HttpResponse<{}>;\n    return headers.get(\"ETag\");\n  }\n\n  /**\n   * Retrieves collection data.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Object} [options.query]   Query parameters to pass in\n   *     the request. This might be useful for features that aren't\n   *     yet supported by this library.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async getData<T>(\n    options: {\n      headers?: Record<string, string>;\n      query?: { [key: string]: string };\n      fields?: string[];\n      retry?: number;\n    } = {}\n  ): Promise<T> {\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const request = { headers: this._getHeaders(options), path };\n    const { data } =\n      (await this.client.execute(request, {\n        retry: this._getRetry(options),\n        query: options.query,\n        fields: options.fields,\n      })) as { data: T };\n    return data;\n  }\n\n  /**\n   * Set collection data.\n   * @param  {Object}   data                    The collection data object.\n   * @param  {Object}   [options={}]            The options object.\n   * @param  {Object}   [options.headers]       The headers object option.\n   * @param  {Number}   [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean}  [options.safe]          The safe option.\n   * @param  {Boolean}  [options.patch]         The patch option.\n   * @param  {Number}   [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async setData<T extends MappableObject>(\n    data: T & { last_modified?: number },\n    options: {\n      headers?: Record<string, string>;\n      safe?: boolean;\n      retry?: number;\n      patch?: boolean;\n      last_modified?: number;\n      permissions?: { [key in Permission]?: string[] };\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    if (!isObject(data)) {\n      throw new Error(\"A collection object is required.\");\n    }\n    const { patch, permissions } = options;\n    const { last_modified } = { ...data, ...options };\n\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const request = requests.updateRequest(\n      path,\n      { data, permissions },\n      {\n        last_modified,\n        patch,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return (\n      this.client.execute<KintoResponse<T>>(request, {\n        retry: this._getRetry(options),\n      }) as Promise<KintoResponse<T>>\n    );\n  }\n\n  /**\n   * Retrieves the list of permissions for this collection.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async getPermissions(\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<{ [key in Permission]?: string[] }> {\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const request = { headers: this._getHeaders(options), path };\n    const { permissions } =\n      (await this.client.execute<KintoResponse>(request, {\n        retry: this._getRetry(options),\n      })) as KintoResponse;\n    return permissions;\n  }\n\n  /**\n   * Replaces all existing collection permissions with the ones provided.\n   *\n   * @param  {Object}   permissions             The permissions object.\n   * @param  {Object}   [options={}]            The options object\n   * @param  {Object}   [options.headers]       The headers object option.\n   * @param  {Number}   [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean}  [options.safe]          The safe option.\n   * @param  {Number}   [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async setPermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const data = { last_modified: options.last_modified };\n    const request = requests.updateRequest(\n      path,\n      { data, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return (\n      this.client.execute<KintoResponse<{}>>(request, {\n        retry: this._getRetry(options),\n      }) as Promise<KintoResponse<{}>>\n    );\n  }\n\n  /**\n   * Append principals to the collection permissions.\n   *\n   * @param  {Object}  permissions             The permissions object.\n   * @param  {Object}  [options={}]            The options object\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async addPermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const { last_modified } = options;\n    const request = requests.jsonPatchPermissionsRequest(\n      path,\n      permissions,\n      \"add\",\n      {\n        last_modified,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return (\n      this.client.execute<KintoResponse<{}>>(request, {\n        retry: this._getRetry(options),\n      }) as Promise<KintoResponse<{}>>\n    );\n  }\n\n  /**\n   * Remove principals from the collection permissions.\n   *\n   * @param  {Object}  permissions             The permissions object.\n   * @param  {Object}  [options={}]            The options object\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async removePermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.collection(this.bucket.name, this.name);\n    const { last_modified } = options;\n    const request = requests.jsonPatchPermissionsRequest(\n      path,\n      permissions,\n      \"remove\",\n      {\n        last_modified,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return (\n      this.client.execute<KintoResponse<{}>>(request, {\n        retry: this._getRetry(options),\n      }) as Promise<KintoResponse<{}>>\n    );\n  }\n\n  /**\n   * Creates a record in current collection.\n   *\n   * @param  {Object}  record                The record to create.\n   * @param  {Object}  [options={}]          The options object.\n   * @param  {Object}  [options.headers]     The headers object option.\n   * @param  {Number}  [options.retry=0]     Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean} [options.safe]        The safe option.\n   * @param  {Object}  [options.permissions] The permissions option.\n   * @return {Promise<Object, Error>}\n   */\n  async createRecord<T extends MappableObject>(\n    record: T & { id?: string },\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      permissions?: { [key in Permission]?: string[] };\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    const { permissions } = options;\n    const path = this._endpoints.record(this.bucket.name, this.name, record.id);\n    const request = requests.createRequest(\n      path,\n      { data: record, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return (\n      this.client.execute<KintoResponse<T>>(request, {\n        retry: this._getRetry(options),\n      }) as Promise<KintoResponse<T>>\n    );\n  }\n\n  /**\n   * Adds an attachment to a record, creating the record when it doesn't exist.\n   *\n   * @param  {String}  dataURL                 The data url.\n   * @param  {Object}  [record={}]             The record data.\n   * @param  {Object}  [options={}]            The options object.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   * @param  {Object}  [options.permissions]   The permissions option.\n   * @param  {String}  [options.filename]      Force the attachment filename.\n   * @param  {String}  [options.gzipped]       Force the attachment to be gzipped or not.\n   * @return {Promise<Object, Error>}\n   */\n  @capable([\"attachments\"])\n  async addAttachment(\n    dataURI: string,\n    record: { [key: string]: string } = {},\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n      permissions?: { [key in Permission]?: string[] };\n      filename?: string;\n      gzipped?: boolean;\n    } = {}\n  ): Promise<\n    KintoResponse<{\n      attachment: Attachment;\n    }>\n  > {\n    const { permissions } = options;\n    const id = record.id || uuid();\n    const path = this._endpoints.attachment(this.bucket.name, this.name, id);\n    const { last_modified } = { ...record, ...options };\n    const addAttachmentRequest = requests.addAttachmentRequest(\n      path,\n      dataURI,\n      { data: record, permissions },\n      {\n        last_modified,\n        filename: options.filename,\n        gzipped: options.gzipped,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    await this.client.execute(addAttachmentRequest, {\n      stringify: false,\n      retry: this._getRetry(options),\n    });\n    return this.getRecord<{ attachment: Attachment }>(id);\n  }\n\n  /**\n   * Removes an attachment from a given record.\n   *\n   * @param  {Object}  recordId                The record id.\n   * @param  {Object}  [options={}]            The options object.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   */\n  @capable([\"attachments\"])\n  async removeAttachment(\n    recordId: string,\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n    } = {}\n  ): Promise<{}> {\n    const { last_modified } = options;\n    const path = this._endpoints.attachment(\n      this.bucket.name,\n      this.name,\n      recordId\n    );\n    const request = requests.deleteRequest(path, {\n      last_modified,\n      headers: this._getHeaders(options),\n      safe: this._getSafe(options),\n    });\n    return (\n      this.client.execute<{}>(request, {\n        retry: this._getRetry(options),\n      }) as Promise<{}>\n    );\n  }\n\n  /**\n   * Updates a record in current collection.\n   *\n   * @param  {Object}  record                  The record to update.\n   * @param  {Object}  [options={}]            The options object.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   * @param  {Object}  [options.permissions]   The permissions option.\n   * @return {Promise<Object, Error>}\n   */\n  async updateRecord<T>(\n    record: T & { id: string },\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n      permissions?: { [key in Permission]?: string[] };\n      patch?: boolean;\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    if (!isObject(record)) {\n      throw new Error(\"A record object is required.\");\n    }\n    if (!record.id) {\n      throw new Error(\"A record id is required.\");\n    }\n    const { permissions } = options;\n    const { last_modified } = { ...record, ...options };\n    const path = this._endpoints.record(this.bucket.name, this.name, record.id);\n    const request = requests.updateRequest(\n      path,\n      { data: record, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n        last_modified,\n        patch: !!options.patch,\n      }\n    );\n    return (\n      this.client.execute<KintoResponse<T>>(request, {\n        retry: this._getRetry(options),\n      }) as Promise<KintoResponse<T>>\n    );\n  }\n\n  /**\n   * Deletes a record from the current collection.\n   *\n   * @param  {Object|String} record                  The record to delete.\n   * @param  {Object}        [options={}]            The options object.\n   * @param  {Object}        [options.headers]       The headers object option.\n   * @param  {Number}        [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean}       [options.safe]          The safe option.\n   * @param  {Number}        [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async deleteRecord(\n    record: string | KintoIdObject,\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{ deleted: boolean }>> {\n    const recordObj = toDataBody(record);\n    if (!recordObj.id) {\n      throw new Error(\"A record id is required.\");\n    }\n    const { id } = recordObj;\n    const { last_modified } = { ...recordObj, ...options };\n    const path = this._endpoints.record(this.bucket.name, this.name, id);\n    const request = requests.deleteRequest(path, {\n      last_modified,\n      headers: this._getHeaders(options),\n      safe: this._getSafe(options),\n    });\n    return (\n      this.client.execute<KintoResponse<{ deleted: boolean }>>(request, {\n        retry: this._getRetry(options),\n      }) as Promise<KintoResponse<{ deleted: boolean }>>\n    );\n  }\n\n  /**\n   * Retrieves a record from the current collection.\n   *\n   * @param  {String} id                The record id to retrieve.\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Object} [options.query]   Query parameters to pass in\n   *     the request. This might be useful for features that aren't\n   *     yet supported by this library.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async getRecord<T>(\n    id: string,\n    options: {\n      headers?: Record<string, string>;\n      query?: { [key: string]: string };\n      fields?: string[];\n      retry?: number;\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    const path = this._endpoints.record(this.bucket.name, this.name, id);\n    const request = { headers: this._getHeaders(options), path };\n    return (\n      this.client.execute<KintoResponse<T>>(request, {\n        retry: this._getRetry(options),\n        query: options.query,\n        fields: options.fields,\n      }) as Promise<KintoResponse<T>>\n    );\n  }\n\n  /**\n   * Lists records from the current collection.\n   *\n   * Sorting is done by passing a `sort` string option:\n   *\n   * - The field to order the results by, prefixed with `-` for descending.\n   * Default: `-last_modified`.\n   *\n   * @see http://kinto.readthedocs.io/en/stable/api/1.x/sorting.html\n   *\n   * Filtering is done by passing a `filters` option object:\n   *\n   * - `{fieldname: \"value\"}`\n   * - `{min_fieldname: 4000}`\n   * - `{in_fieldname: \"1,2,3\"}`\n   * - `{not_fieldname: 0}`\n   * - `{exclude_fieldname: \"0,1\"}`\n   *\n   * @see http://kinto.readthedocs.io/en/stable/api/1.x/filtering.html\n   *\n   * Paginating is done by passing a `limit` option, then calling the `next()`\n   * method from the resolved result object to fetch the next page, if any.\n   *\n   * @param  {Object}   [options={}]                    The options object.\n   * @param  {Object}   [options.headers]               The headers object option.\n   * @param  {Number}   [options.retry=0]               Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}   [options.filters={}]            The filters object.\n   * @param  {String}   [options.sort=\"-last_modified\"] The sort field.\n   * @param  {String}   [options.at]                    The timestamp to get a snapshot at.\n   * @param  {String}   [options.limit=null]            The limit field.\n   * @param  {String}   [options.pages=1]               The number of result pages to aggregate.\n   * @param  {Number}   [options.since=null]            Only retrieve records modified since the provided timestamp.\n   * @param  {Array}    [options.fields]                Limit response to just some fields.\n   * @return {Promise<Object, Error>}\n   */\n  async listRecords<T extends KintoObject>(\n    options: PaginatedListParams & {\n      headers?: Record<string, string>;\n      retry?: number;\n      at?: number;\n    } = {}\n  ): Promise<PaginationResult<T>> {\n    const path = this._endpoints.record(this.bucket.name, this.name);\n    if (options.at) {\n      return this.getSnapshot<T>(options.at);\n    } else {\n      return this.client.paginatedList<T>(path, options, {\n        headers: this._getHeaders(options),\n        retry: this._getRetry(options),\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  async isHistoryComplete(): Promise<boolean> {\n    // We consider that if we have the collection creation event part of the\n    // history, then all records change events have been tracked.\n    const {\n      data: [oldestHistoryEntry],\n    } = await this.bucket.listHistory({\n      limit: 1,\n      filters: {\n        action: \"create\",\n        resource_name: \"collection\",\n        collection_id: this.name,\n      },\n    });\n    return !!oldestHistoryEntry;\n  }\n\n  /**\n   * @private\n   */\n  async listChangesBackTo<T>(at: number): Promise<HistoryEntry<T>[]> {\n    // Ensure we have enough history data to retrieve the complete list of\n    // changes.\n    if (!(await this.isHistoryComplete())) {\n      throw new Error(\n        \"Computing a snapshot is only possible when the full history for a \" +\n          \"collection is available. Here, the history plugin seems to have \" +\n          \"been enabled after the creation of the collection.\"\n      );\n    }\n    const { data: changes } = await this.bucket.listHistory<T>({\n      pages: Infinity, // all pages up to target timestamp are required\n      sort: \"-target.data.last_modified\",\n      filters: {\n        resource_name: \"record\",\n        collection_id: this.name,\n        \"max_target.data.last_modified\": String(at), // eq. to <=\n      },\n    });\n    return changes;\n  }\n\n  /**\n   * @private\n   */\n  @capable([\"history\"])\n  async getSnapshot<T extends KintoObject>(\n    at: number\n  ): Promise<PaginationResult<T>> {\n    if (!at || !Number.isInteger(at) || at <= 0) {\n      throw new Error(\"Invalid argument, expected a positive integer.\");\n    }\n    // Retrieve history and check it covers the required time range.\n    const changes = await this.listChangesBackTo<T>(at);\n    // Replay changes to compute the requested snapshot.\n    const seenIds = new Set();\n    let snapshot: T[] = [];\n    for (const {\n      action,\n      target: { data: record },\n    } of changes) {\n      if (action == \"delete\") {\n        seenIds.add(record.id); // ensure not reprocessing deleted entries\n        snapshot = snapshot.filter((r) => r.id !== record.id);\n      } else if (!seenIds.has(record.id)) {\n        seenIds.add(record.id);\n        snapshot.push(record);\n      }\n    }\n    return (\n      {\n        last_modified: String(at),\n        data: snapshot.sort((a, b) => b.last_modified - a.last_modified),\n        next: () => {\n          throw new Error(\"Snapshots don't support pagination\");\n        },\n        hasNextPage: false,\n        totalRecords: snapshot.length,\n      } as PaginationResult<T>\n    );\n  }\n\n  /**\n   * Performs batch operations at the current collection level.\n   *\n   * @param  {Function} fn                   The batch operation function.\n   * @param  {Object}   [options={}]         The options object.\n   * @param  {Object}   [options.headers]    The headers object option.\n   * @param  {Boolean}  [options.safe]       The safe option.\n   * @param  {Number}   [options.retry]      The retry option.\n   * @param  {Boolean}  [options.aggregate]  Produces a grouped result object.\n   * @return {Promise<Object, Error>}\n   */\n  async batch(\n    fn: (client: Collection) => void,\n    options: {\n      headers?: Record<string, string>;\n      safe?: boolean;\n      retry?: number;\n      aggregate?: boolean;\n    } = {}\n  ): Promise<OperationResponse<KintoObject>[] | AggregateResponse> {\n    return this.client.batch(fn, {\n      bucket: this.bucket.name,\n      collection: this.name,\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n      safe: this._getSafe(options),\n      aggregate: !!options.aggregate,\n    });\n  }\n}\n","import { toDataBody, isObject, capable } from \"./utils\";\nimport Collection from \"./collection\";\nimport * as requests from \"./requests\";\nimport KintoClientBase, { PaginatedListParams, PaginationResult } from \"./base\";\nimport {\n  KintoRequest,\n  KintoIdObject,\n  Permission,\n  KintoResponse,\n  HistoryEntry,\n  KintoObject,\n  Group,\n  OperationResponse,\n  MappableObject,\n} from \"./types\";\nimport { HttpResponse } from \"./http\";\nimport { AggregateResponse } from \"./batch\";\n\nexport interface BucketOptions {\n  safe?: boolean;\n  headers?: Record<string, string>;\n  retry?: number;\n}\n/**\n * Abstract representation of a selected bucket.\n *\n */\nexport default class Bucket {\n  private client: KintoClientBase;\n  public name: string;\n  private _endpoints: KintoClientBase[\"endpoints\"];\n  private _retry: number;\n  private _safe: boolean;\n  private _headers: Record<string, string>;\n\n  /**\n   * Constructor.\n   *\n   * @param  {KintoClient} client            The client instance.\n   * @param  {String}      name              The bucket name.\n   * @param  {Object}      [options={}]      The headers object option.\n   * @param  {Object}      [options.headers] The headers object option.\n   * @param  {Boolean}     [options.safe]    The safe option.\n   * @param  {Number}      [options.retry]   The retry option.\n   */\n  constructor(\n    client: KintoClientBase,\n    name: string,\n    options: BucketOptions = {}\n  ) {\n    /**\n     * @ignore\n     */\n    this.client = client;\n    /**\n     * The bucket name.\n     * @type {String}\n     */\n    this.name = name;\n\n    this._endpoints = client.endpoints;\n\n    /**\n     * @ignore\n     */\n    this._headers = options.headers || {};\n    this._retry = options.retry || 0;\n    this._safe = !!options.safe;\n  }\n\n  get headers(): Record<string, string> {\n    return this._headers;\n  }\n\n  /**\n   * Get the value of \"headers\" for a given request, merging the\n   * per-request headers with our own \"default\" headers.\n   *\n   * @private\n   */\n  private _getHeaders(options: {\n    headers?: Record<string, string>;\n  }): Record<string, string> {\n    return {\n      ...this._headers,\n      ...options.headers,\n    };\n  }\n\n  /**\n   * Get the value of \"safe\" for a given request, using the\n   * per-request option if present or falling back to our default\n   * otherwise.\n   *\n   * @private\n   * @param {Object} options The options for a request.\n   * @returns {Boolean}\n   */\n  private _getSafe(options: { safe?: boolean }): boolean {\n    return { safe: this._safe, ...options }.safe;\n  }\n\n  /**\n   * As _getSafe, but for \"retry\".\n   *\n   * @private\n   */\n  private _getRetry(options: { retry?: number }): number {\n    return { retry: this._retry, ...options }.retry;\n  }\n\n  /**\n   * Selects a collection.\n   *\n   * @param  {String}  name              The collection name.\n   * @param  {Object}  [options={}]      The options object.\n   * @param  {Object}  [options.headers] The headers object option.\n   * @param  {Boolean} [options.safe]    The safe option.\n   * @return {Collection}\n   */\n  collection(\n    name: string,\n    options: {\n      headers?: Record<string, string>;\n      safe?: boolean;\n      retry?: number;\n    } = {}\n  ): Collection {\n    return new Collection(this.client, this, name, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n      safe: this._getSafe(options),\n    });\n  }\n\n  /**\n   * Retrieves the ETag of the collection list, for use with the `since` filtering option.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<String, Error>}\n   */\n  async getCollectionsTimestamp(\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<string | null> {\n    const path = this._endpoints.collection(this.name);\n    const request: KintoRequest = {\n      headers: this._getHeaders(options),\n      path,\n      method: \"HEAD\",\n    };\n    const { headers } =\n      (await this.client.execute(request, {\n        raw: true,\n        retry: this._getRetry(options),\n      })) as HttpResponse<{}>;\n    return headers.get(\"ETag\");\n  }\n\n  /**\n   * Retrieves the ETag of the group list, for use with the `since` filtering option.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<String, Error>}\n   */\n  async getGroupsTimestamp(\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<string | null> {\n    const path = this._endpoints.group(this.name);\n    const request: KintoRequest = {\n      headers: this._getHeaders(options),\n      path,\n      method: \"HEAD\",\n    };\n    const { headers } =\n      (await this.client.execute(request, {\n        raw: true,\n        retry: this._getRetry(options),\n      })) as HttpResponse<{}>;\n    return headers.get(\"ETag\");\n  }\n\n  /**\n   * Retrieves bucket data.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Object} [options.query]   Query parameters to pass in\n   *     the request. This might be useful for features that aren't\n   *     yet supported by this library.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async getData<T>(\n    options: {\n      headers?: Record<string, string>;\n      query?: { [key: string]: string };\n      fields?: string[];\n      retry?: number;\n    } = {}\n  ): Promise<T> {\n    const path = this._endpoints.bucket(this.name);\n    const request = {\n      headers: this._getHeaders(options),\n      path,\n    };\n    const { data } =\n      (await this.client.execute(request, {\n        retry: this._getRetry(options),\n        query: options.query,\n        fields: options.fields,\n      })) as { data: T };\n    return data;\n  }\n\n  /**\n   * Set bucket data.\n   * @param  {Object}  data                    The bucket data object.\n   * @param  {Object}  [options={}]            The options object.\n   * @param  {Object}  [options.headers={}]    The headers object option.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean} [options.patch]         The patch option.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async setData<T extends MappableObject>(\n    data: T & { last_modified?: number },\n    options: {\n      headers?: Record<string, string>;\n      safe?: boolean;\n      retry?: number;\n      patch?: boolean;\n      last_modified?: number;\n      permissions?: { [key in Permission]?: string[] };\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    if (!isObject(data)) {\n      throw new Error(\"A bucket object is required.\");\n    }\n\n    const bucket = { ...data, id: this.name };\n\n    // For default bucket, we need to drop the id from the data object.\n    // Bug in Kinto < 3.1.1\n    const bucketId = bucket.id;\n    if (bucket.id === \"default\") {\n      delete bucket.id;\n    }\n\n    const path = this._endpoints.bucket(bucketId);\n    const { patch, permissions } = options;\n    const { last_modified } = { ...data, ...options };\n    const request = requests.updateRequest(\n      path,\n      { data: bucket, permissions },\n      {\n        last_modified,\n        patch,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return (\n      this.client.execute<KintoResponse<T>>(request, {\n        retry: this._getRetry(options),\n      }) as Promise<KintoResponse<T>>\n    );\n  }\n\n  /**\n   * Retrieves the list of history entries in the current bucket.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Array<Object>, Error>}\n   */\n  @capable([\"history\"])\n  async listHistory<T>(\n    options: PaginatedListParams & {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<PaginationResult<HistoryEntry<T>>> {\n    const path = this._endpoints.history(this.name);\n    return this.client.paginatedList<HistoryEntry<T>>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Retrieves the list of collections in the current bucket.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.filters={}] The filters object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @return {Promise<Array<Object>, Error>}\n   */\n  async listCollections(\n    options: PaginatedListParams & {\n      filters?: Record<string, string | number>;\n      headers?: Record<string, string>;\n      retry?: number;\n      fields?: string[];\n    } = {}\n  ): Promise<PaginationResult<KintoObject>> {\n    const path = this._endpoints.collection(this.name);\n    return this.client.paginatedList<KintoObject>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Creates a new collection in current bucket.\n   *\n   * @param  {String|undefined}  id          The collection id.\n   * @param  {Object}  [options={}]          The options object.\n   * @param  {Boolean} [options.safe]        The safe option.\n   * @param  {Object}  [options.headers]     The headers object option.\n   * @param  {Number}  [options.retry=0]     Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.permissions] The permissions object.\n   * @param  {Object}  [options.data]        The data object.\n   * @return {Promise<Object, Error>}\n   */\n  async createCollection(\n    id?: string,\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      permissions?: { [key in Permission]?: string[] };\n      data?: any;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    const { permissions, data = {} } = options;\n    data.id = id;\n    const path = this._endpoints.collection(this.name, id);\n    const request = requests.createRequest(\n      path,\n      { data, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return (\n      this.client.execute<KintoResponse<{}>>(request, {\n        retry: this._getRetry(options),\n      }) as Promise<KintoResponse<{}>>\n    );\n  }\n\n  /**\n   * Deletes a collection from the current bucket.\n   *\n   * @param  {Object|String} collection              The collection to delete.\n   * @param  {Object}        [options={}]            The options object.\n   * @param  {Object}        [options.headers]       The headers object option.\n   * @param  {Number}        [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean}       [options.safe]          The safe option.\n   * @param  {Number}        [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async deleteCollection(\n    collection: string | KintoIdObject,\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{ deleted: boolean }>> {\n    const collectionObj = toDataBody(collection);\n    if (!collectionObj.id) {\n      throw new Error(\"A collection id is required.\");\n    }\n    const { id } = collectionObj;\n    const { last_modified } = { ...collectionObj, ...options };\n    const path = this._endpoints.collection(this.name, id);\n    const request = requests.deleteRequest(path, {\n      last_modified,\n      headers: this._getHeaders(options),\n      safe: this._getSafe(options),\n    });\n    return (\n      this.client.execute<KintoResponse<{ deleted: boolean }>>(request, {\n        retry: this._getRetry(options),\n      }) as Promise<KintoResponse<{ deleted: boolean }>>\n    );\n  }\n\n  /**\n   * Retrieves the list of groups in the current bucket.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.filters={}] The filters object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @return {Promise<Array<Object>, Error>}\n   */\n  async listGroups(\n    options: PaginatedListParams & {\n      filters?: Record<string, string | number>;\n      headers?: Record<string, string>;\n      retry?: number;\n      fields?: string[];\n    } = {}\n  ): Promise<PaginationResult<Group>> {\n    const path = this._endpoints.group(this.name);\n    return this.client.paginatedList<Group>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Fetches a group in current bucket.\n   *\n   * @param  {String} id                The group id.\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object} [options.query]   Query parameters to pass in\n   *     the request. This might be useful for features that aren't\n   *     yet supported by this library.\n   * @param  {Array}  [options.fields]  Limit response to\n   *     just some fields.\n   * @return {Promise<Object, Error>}\n   */\n  async getGroup(\n    id: string,\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      query?: { [key: string]: string };\n      fields?: string[];\n    } = {}\n  ): Promise<KintoResponse<Group>> {\n    const path = this._endpoints.group(this.name, id);\n    const request = {\n      headers: this._getHeaders(options),\n      path,\n    };\n    return (\n      this.client.execute<KintoResponse<Group>>(request, {\n        retry: this._getRetry(options),\n        query: options.query,\n        fields: options.fields,\n      }) as Promise<KintoResponse<Group>>\n    );\n  }\n\n  /**\n   * Creates a new group in current bucket.\n   *\n   * @param  {String|undefined}  id                    The group id.\n   * @param  {Array<String>}     [members=[]]          The list of principals.\n   * @param  {Object}            [options={}]          The options object.\n   * @param  {Object}            [options.data]        The data object.\n   * @param  {Object}            [options.permissions] The permissions object.\n   * @param  {Boolean}           [options.safe]        The safe option.\n   * @param  {Object}            [options.headers]     The headers object option.\n   * @param  {Number}            [options.retry=0]     Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async createGroup(\n    id?: string,\n    members: string[] = [],\n    options: {\n      data?: any;\n      permissions?: { [key in Permission]?: string[] };\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<KintoResponse<Group>> {\n    const data = {\n      ...options.data,\n      id,\n      members,\n    };\n    const path = this._endpoints.group(this.name, id);\n    const { permissions } = options;\n    const request = requests.createRequest(\n      path,\n      { data, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return (\n      this.client.execute<KintoResponse<Group>>(request, {\n        retry: this._getRetry(options),\n      }) as Promise<KintoResponse<Group>>\n    );\n  }\n\n  /**\n   * Updates an existing group in current bucket.\n   *\n   * @param  {Object}  group                   The group object.\n   * @param  {Object}  [options={}]            The options object.\n   * @param  {Object}  [options.data]          The data object.\n   * @param  {Object}  [options.permissions]   The permissions object.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async updateGroup<T extends MappableObject>(\n    group: KintoIdObject,\n    options: {\n      data?: T & { members?: string[] };\n      permissions?: { [key in Permission]?: string[] };\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n      patch?: boolean;\n    } = {}\n  ): Promise<KintoResponse<T & { members: string[] }>> {\n    if (!isObject(group)) {\n      throw new Error(\"A group object is required.\");\n    }\n    if (!group.id) {\n      throw new Error(\"A group id is required.\");\n    }\n    const data = {\n      ...options.data,\n      ...group,\n    };\n    const path = this._endpoints.group(this.name, group.id);\n    const { patch, permissions } = options;\n    const { last_modified } = { ...data, ...options };\n    const request = requests.updateRequest(\n      path,\n      { data, permissions },\n      {\n        last_modified,\n        patch,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return (\n      this.client.execute<KintoResponse<T & { members: string[] }>>(request, {\n        retry: this._getRetry(options),\n      }) as Promise<KintoResponse<T & { members: string[] }>>\n    );\n  }\n\n  /**\n   * Deletes a group from the current bucket.\n   *\n   * @param  {Object|String} group                   The group to delete.\n   * @param  {Object}        [options={}]            The options object.\n   * @param  {Object}        [options.headers]       The headers object option.\n   * @param  {Number}        [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Boolean}       [options.safe]          The safe option.\n   * @param  {Number}        [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async deleteGroup(\n    group: string | KintoIdObject,\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n      safe?: boolean;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{ deleted: boolean }>> {\n    const groupObj = toDataBody(group);\n    const { id } = groupObj;\n    const { last_modified } = { ...groupObj, ...options };\n    const path = this._endpoints.group(this.name, id);\n    const request = requests.deleteRequest(path, {\n      last_modified,\n      headers: this._getHeaders(options),\n      safe: this._getSafe(options),\n    });\n    return (\n      this.client.execute<KintoResponse<{ deleted: boolean }>>(request, {\n        retry: this._getRetry(options),\n      }) as Promise<KintoResponse<{ deleted: boolean }>>\n    );\n  }\n\n  /**\n   * Retrieves the list of permissions for this bucket.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers] The headers object option.\n   * @param  {Number} [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async getPermissions(\n    options: {\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<{ [key in Permission]?: string[] }> {\n    const request = {\n      headers: this._getHeaders(options),\n      path: this._endpoints.bucket(this.name),\n    };\n    const { permissions } =\n      (await this.client.execute<KintoResponse>(request, {\n        retry: this._getRetry(options),\n      })) as KintoResponse;\n    return permissions;\n  }\n\n  /**\n   * Replaces all existing bucket permissions with the ones provided.\n   *\n   * @param  {Object}  permissions             The permissions object.\n   * @param  {Object}  [options={}]            The options object\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers={}]    The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async setPermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.bucket(this.name);\n    const { last_modified } = options;\n    const data = { last_modified };\n    const request = requests.updateRequest(\n      path,\n      { data, permissions },\n      {\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return (\n      this.client.execute<KintoResponse<{}>>(request, {\n        retry: this._getRetry(options),\n      }) as Promise<KintoResponse<{}>>\n    );\n  }\n\n  /**\n   * Append principals to the bucket permissions.\n   *\n   * @param  {Object}  permissions             The permissions object.\n   * @param  {Object}  [options={}]            The options object\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async addPermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.bucket(this.name);\n    const { last_modified } = options;\n    const request = requests.jsonPatchPermissionsRequest(\n      path,\n      permissions,\n      \"add\",\n      {\n        last_modified,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return (\n      this.client.execute<KintoResponse<{}>>(request, {\n        retry: this._getRetry(options),\n      }) as Promise<KintoResponse<{}>>\n    );\n  }\n\n  /**\n   * Remove principals from the bucket permissions.\n   *\n   * @param  {Object}  permissions             The permissions object.\n   * @param  {Object}  [options={}]            The options object\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async removePermissions(\n    permissions: { [key in Permission]?: string[] },\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{}>> {\n    if (!isObject(permissions)) {\n      throw new Error(\"A permissions object is required.\");\n    }\n    const path = this._endpoints.bucket(this.name);\n    const { last_modified } = options;\n    const request = requests.jsonPatchPermissionsRequest(\n      path,\n      permissions,\n      \"remove\",\n      {\n        last_modified,\n        headers: this._getHeaders(options),\n        safe: this._getSafe(options),\n      }\n    );\n    return (\n      this.client.execute<KintoResponse<{}>>(request, {\n        retry: this._getRetry(options),\n      }) as Promise<KintoResponse<{}>>\n    );\n  }\n\n  /**\n   * Performs batch operations at the current bucket level.\n   *\n   * @param  {Function} fn                   The batch operation function.\n   * @param  {Object}   [options={}]         The options object.\n   * @param  {Object}   [options.headers]    The headers object option.\n   * @param  {Boolean}  [options.safe]       The safe option.\n   * @param  {Number}   [options.retry=0]    The retry option.\n   * @param  {Boolean}  [options.aggregate]  Produces a grouped result object.\n   * @return {Promise<Object, Error>}\n   */\n  async batch(\n    fn: (client: Bucket) => void,\n    options: {\n      headers?: Record<string, string>;\n      safe?: boolean;\n      retry?: number;\n      aggregate?: boolean;\n    } = {}\n  ): Promise<OperationResponse<KintoObject>[] | AggregateResponse> {\n    return this.client.batch(fn, {\n      bucket: this.name,\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n      safe: this._getSafe(options),\n      aggregate: !!options.aggregate,\n    });\n  }\n}\n","import KintoClientBase, { KintoClientOptions, SUPPORTED_PROTOCOL_VERSION } from \"./base\";\nimport { AggregateResponse } from \"./batch\";\nimport Collection from \"./collection\";\nimport { KintoObject, KintoIdObject, KintoResponse, Permission } from \"./types\";\n\nexport default class KintoClient extends KintoClientBase {\n  constructor(remote: string, options: Partial<KintoClientOptions> = {}) {\n    const events = options.events;\n\n    super(remote, Object.assign({ events }, options));\n  }\n}\n\nexport {\n  KintoObject,\n  KintoIdObject,\n  Collection,\n  AggregateResponse,\n  KintoResponse,\n  Permission,\n  SUPPORTED_PROTOCOL_VERSION\n};\n","import {\n  partition,\n  qsify,\n  support,\n  nobatch,\n  toDataBody,\n  cleanUndefinedProperties,\n} from \"./utils\";\nimport HTTP, { HttpResponse } from \"./http\";\nimport endpoints from \"./endpoints\";\nimport * as requests from \"./requests\";\nimport { aggregate, AggregateResponse } from \"./batch\";\nimport Bucket from \"./bucket\";\nimport { addEndpointOptions, capable } from \"./utils\";\nimport {\n  HelloResponse,\n  KintoRequest,\n  BatchResponse,\n  OperationResponse,\n  DataResponse,\n  Permission,\n  KintoIdObject,\n  MappableObject,\n  KintoObject,\n  PermissionData,\n  KintoResponse,\n  ServerSettings,\n  ServerCapability,\n  User,\n  Emitter,\n} from \"./types\";\nimport Collection from \"./collection\";\n\n/**\n * Currently supported protocol version.\n * @type {String}\n */\nexport const SUPPORTED_PROTOCOL_VERSION = \"v1\";\n\nexport interface KintoClientOptions {\n  safe?: boolean;\n  events?: Emitter;\n  headers?: Record<string, string>;\n  retry?: number;\n  bucket?: string;\n  requestMode?: RequestMode;\n  timeout?: number;\n  batch?: boolean;\n}\n\nexport interface PaginatedListParams {\n  sort?: string;\n  filters?: Record<string, string | number>;\n  limit?: number;\n  pages?: number;\n  since?: string;\n  fields?: string[];\n}\n\nexport interface PaginationResult<T> {\n  last_modified: string | null;\n  data: T[];\n  next: (nextPage?: string | null) => Promise<PaginationResult<T>>;\n  hasNextPage: boolean;\n  totalRecords: number;\n}\n\ntype BaseBatch = (client: KintoClientBase) => void;\ntype BucketBatch = (client: Bucket) => void;\ntype CollectionBatch = (client: Collection) => void;\n\n/**\n * High level HTTP client for the Kinto API.\n *\n * @example\n * const client = new KintoClient(\"https://kinto.dev.mozaws.net/v1\");\n * client.bucket(\"default\")\n *    .collection(\"my-blog\")\n *    .createRecord({title: \"First article\"})\n *   .then(console.log.bind(console))\n *   .catch(console.error.bind(console));\n */\nexport default class KintoClientBase {\n  private _backoffReleaseTime: number | null;\n  private _requests: KintoRequest[];\n  private _isBatch: boolean;\n  private _retry: number;\n  private _safe: boolean;\n  private _headers: Record<string, string>;\n  public serverInfo: HelloResponse | null;\n  public events?: Emitter;\n  public http: HTTP;\n  public endpoints: typeof endpoints;\n  private _remote!: string;\n  private _version!: string;\n\n  /**\n   * Constructor.\n   *\n   * @param  {String}       remote  The remote URL.\n   * @param  {Object}       [options={}]                  The options object.\n   * @param  {Boolean}      [options.safe=true]           Adds concurrency headers to every requests.\n   * @param  {EventEmitter} [options.events=EventEmitter] The events handler instance.\n   * @param  {Object}       [options.headers={}]          The key-value headers to pass to each request.\n   * @param  {Object}       [options.retry=0]             Number of retries when request fails (default: 0)\n   * @param  {String}       [options.bucket=\"default\"]    The default bucket to use.\n   * @param  {String}       [options.requestMode=\"cors\"]  The HTTP request mode (from ES6 fetch spec).\n   * @param  {Number}       [options.timeout=null]        The request timeout in ms, if any.\n   */\n  constructor(remote: string, options: KintoClientOptions) {\n    if (typeof remote !== \"string\" || !remote.length) {\n      throw new Error(\"Invalid remote URL: \" + remote);\n    }\n    if (remote[remote.length - 1] === \"/\") {\n      remote = remote.slice(0, -1);\n    }\n    this._backoffReleaseTime = null;\n\n    this._requests = [];\n    this._isBatch = !!options.batch;\n    this._retry = options.retry || 0;\n    this._safe = !!options.safe;\n    this._headers = options.headers || {};\n\n    // public properties\n    /**\n     * The remote server base URL.\n     * @type {String}\n     */\n    this.remote = remote;\n    /**\n     * Current server information.\n     * @ignore\n     * @type {Object|null}\n     */\n    this.serverInfo = null;\n    /**\n     * The event emitter instance. Should comply with the `EventEmitter`\n     * interface.\n     * @ignore\n     * @type {Class}\n     */\n    this.events = options.events;\n\n    this.endpoints = endpoints;\n\n    const { requestMode, timeout } = options;\n    /**\n     * The HTTP instance.\n     * @ignore\n     * @type {HTTP}\n     */\n    this.http = new HTTP(this.events, { requestMode, timeout });\n    this._registerHTTPEvents();\n  }\n\n  /**\n   * The remote endpoint base URL. Setting the value will also extract and\n   * validate the version.\n   * @type {String}\n   */\n  get remote(): string {\n    return this._remote;\n  }\n\n  /**\n   * @ignore\n   */\n  set remote(url: string) {\n    let version;\n    try {\n      version = url.match(/\\/(v\\d+)\\/?$/)![1];\n    } catch (err) {\n      throw new Error(\"The remote URL must contain the version: \" + url);\n    }\n    if (version !== SUPPORTED_PROTOCOL_VERSION) {\n      throw new Error(`Unsupported protocol version: ${version}`);\n    }\n    this._remote = url;\n    this._version = version;\n  }\n\n  /**\n   * The current server protocol version, eg. `v1`.\n   * @type {String}\n   */\n  get version(): string {\n    return this._version;\n  }\n\n  /**\n   * Backoff remaining time, in milliseconds. Defaults to zero if no backoff is\n   * ongoing.\n   *\n   * @type {Number}\n   */\n  get backoff(): number {\n    const currentTime = new Date().getTime();\n    if (this._backoffReleaseTime && currentTime < this._backoffReleaseTime) {\n      return this._backoffReleaseTime - currentTime;\n    }\n    return 0;\n  }\n\n  /**\n   * Registers HTTP events.\n   * @private\n   */\n  private _registerHTTPEvents(): void {\n    // Prevent registering event from a batch client instance\n    if (!this._isBatch && this.events) {\n      this.events.on(\"backoff\", (backoffMs) => {\n        this._backoffReleaseTime = backoffMs;\n      });\n    }\n  }\n\n  /**\n   * Retrieve a bucket object to perform operations on it.\n   *\n   * @param  {String}  name              The bucket name.\n   * @param  {Object}  [options={}]      The request options.\n   * @param  {Boolean} [options.safe]    The resulting safe option.\n   * @param  {Number}  [options.retry]   The resulting retry option.\n   * @param  {Object}  [options.headers] The extended headers object option.\n   * @return {Bucket}\n   */\n  bucket(\n    name: string,\n    options: {\n      safe?: boolean;\n      retry?: number;\n      headers?: Record<string, string>;\n    } = {}\n  ): Bucket {\n    return new Bucket(this, name, {\n      headers: this._getHeaders(options),\n      safe: this._getSafe(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Set client \"headers\" for every request, updating previous headers (if any).\n   *\n   * @param {Object} headers The headers to merge with existing ones.\n   */\n  setHeaders(headers: Record<string, string>): void {\n    this._headers = {\n      ...this._headers,\n      ...headers,\n    };\n    this.serverInfo = null;\n  }\n\n  /**\n   * Get the value of \"headers\" for a given request, merging the\n   * per-request headers with our own \"default\" headers.\n   *\n   * Note that unlike other options, headers aren't overridden, but\n   * merged instead.\n   *\n   * @private\n   * @param {Object} options The options for a request.\n   * @returns {Object}\n   */\n  private _getHeaders(options: {\n    headers?: Record<string, string>;\n  }): Record<string, string> {\n    return {\n      ...this._headers,\n      ...options.headers,\n    };\n  }\n\n  /**\n   * Get the value of \"safe\" for a given request, using the\n   * per-request option if present or falling back to our default\n   * otherwise.\n   *\n   * @private\n   * @param {Object} options The options for a request.\n   * @returns {Boolean}\n   */\n  private _getSafe(options: { safe?: boolean }): boolean {\n    return { safe: this._safe, ...options }.safe;\n  }\n\n  /**\n   * As _getSafe, but for \"retry\".\n   *\n   * @private\n   */\n  private _getRetry(options: { retry?: number }): number {\n    return { retry: this._retry, ...options }.retry;\n  }\n\n  /**\n   * Retrieves the server's \"hello\" endpoint. This endpoint reveals\n   * server capabilities and settings as well as telling the client\n   * \"who they are\" according to their given authorization headers.\n   *\n   * @private\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Object}  [options.headers={}] Headers to use when making\n   *     this request.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  private async _getHello(\n    options: {\n      retry?: number;\n      headers?: Record<string, string>;\n    } = {}\n  ): Promise<HelloResponse> {\n    const path = this.remote + endpoints.root();\n    const { json } = await this.http.request<HelloResponse>(\n      path,\n      { headers: this._getHeaders(options) },\n      { retry: this._getRetry(options) }\n    );\n    return json;\n  }\n\n  /**\n   * Retrieves server information and persist them locally. This operation is\n   * usually performed a single time during the instance lifecycle.\n   *\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async fetchServerInfo(\n    options: { retry?: number } = {}\n  ): Promise<HelloResponse> {\n    if (this.serverInfo) {\n      return this.serverInfo;\n    }\n    this.serverInfo = await this._getHello({ retry: this._getRetry(options) });\n    return this.serverInfo;\n  }\n\n  /**\n   * Retrieves Kinto server settings.\n   *\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  @nobatch(\"This operation is not supported within a batch operation.\")\n  async fetchServerSettings(\n    options: { retry?: number } = {}\n  ): Promise<ServerSettings> {\n    const { settings } = await this.fetchServerInfo(options);\n    return settings;\n  }\n\n  /**\n   * Retrieve server capabilities information.\n   *\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  @nobatch(\"This operation is not supported within a batch operation.\")\n  async fetchServerCapabilities(\n    options: {\n      retry?: number;\n    } = {}\n  ): Promise<{ [key: string]: ServerCapability }> {\n    const { capabilities } = await this.fetchServerInfo(options);\n    return capabilities;\n  }\n\n  /**\n   * Retrieve authenticated user information.\n   *\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Object}  [options.headers={}] Headers to use when making\n   *     this request.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  @nobatch(\"This operation is not supported within a batch operation.\")\n  async fetchUser(\n    options: {\n      retry?: number;\n      headers?: Record<string, string>;\n    } = {}\n  ): Promise<User | undefined> {\n    const { user } = await this._getHello(options);\n    return user;\n  }\n\n  /**\n   * Retrieve authenticated user information.\n   *\n   * @param  {Object}  [options={}] The request options.\n   * @param  {Number}  [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  @nobatch(\"This operation is not supported within a batch operation.\")\n  async fetchHTTPApiVersion(\n    options: {\n      retry?: number;\n    } = {}\n  ): Promise<string> {\n    const { http_api_version } = await this.fetchServerInfo(options);\n    return http_api_version;\n  }\n\n  /**\n   * Process batch requests, chunking them according to the batch_max_requests\n   * server setting when needed.\n   *\n   * @param  {Array}  requests     The list of batch subrequests to perform.\n   * @param  {Object} [options={}] The options object.\n   * @return {Promise<Object, Error>}\n   */\n  private async _batchRequests(\n    requests: KintoRequest[],\n    options: {\n      retry?: number;\n      headers?: Record<string, string>;\n    } = {}\n  ): Promise<OperationResponse[]> {\n    const headers = this._getHeaders(options);\n    if (!requests.length) {\n      return [];\n    }\n    const serverSettings = await this.fetchServerSettings({\n      retry: this._getRetry(options),\n    });\n    const maxRequests = serverSettings[\"batch_max_requests\"];\n    if (maxRequests && requests.length > maxRequests) {\n      const chunks = partition(requests, maxRequests);\n      const results = [];\n      for (const chunk of chunks) {\n        const result = await this._batchRequests(chunk, options);\n        results.push(...result);\n      }\n      return results;\n    }\n    const { responses } =\n      (await this.execute<BatchResponse>(\n        {\n          // FIXME: is this really necessary, since it's also present in\n          // the \"defaults\"?\n          headers,\n          path: endpoints.batch(),\n          method: \"POST\",\n          body: {\n            defaults: { headers },\n            requests,\n          },\n        },\n        { retry: this._getRetry(options) }\n      )) as BatchResponse;\n    return responses;\n  }\n\n  /**\n   * Sends batch requests to the remote server.\n   *\n   * Note: Reserved for internal use only.\n   *\n   * @ignore\n   * @param  {Function} fn                        The function to use for describing batch ops.\n   * @param  {Object}   [options={}]              The options object.\n   * @param  {Boolean}  [options.safe]            The safe option.\n   * @param  {Number}   [options.retry]           The retry option.\n   * @param  {String}   [options.bucket]          The bucket name option.\n   * @param  {String}   [options.collection]      The collection name option.\n   * @param  {Object}   [options.headers]         The headers object option.\n   * @param  {Boolean}  [options.aggregate=false] Produces an aggregated result object.\n   * @return {Promise<Object, Error>}\n   */\n  @nobatch(\"Can't use batch within a batch!\")\n  async batch(\n    fn: BaseBatch | BucketBatch | CollectionBatch,\n    options: {\n      safe?: boolean;\n      retry?: number;\n      bucket?: string;\n      collection?: string;\n      headers?: Record<string, string>;\n      aggregate?: boolean;\n    } = {}\n  ): Promise<OperationResponse<KintoObject>[] | AggregateResponse> {\n    const rootBatch = new KintoClientBase(this.remote, {\n      events: this.events,\n      batch: true,\n      safe: this._getSafe(options),\n      retry: this._getRetry(options),\n    });\n    if (options.bucket && options.collection) {\n      (fn as CollectionBatch)(\n        rootBatch.bucket(options.bucket).collection(options.collection)\n      );\n    } else if (options.bucket) {\n      (fn as BucketBatch)(rootBatch.bucket(options.bucket));\n    } else {\n      (fn as BaseBatch)(rootBatch);\n    }\n    const responses = await this._batchRequests(rootBatch._requests, options);\n    if (options.aggregate) {\n      return aggregate(responses, rootBatch._requests);\n    } else {\n      return responses;\n    }\n  }\n\n  /**\n   * Executes an atomic HTTP request.\n   *\n   * @private\n   * @param  {Object}  request             The request object.\n   * @param  {String}  request.path        The path to fetch, relative\n   *     to the Kinto server root.\n   * @param  {String}  [request.method=\"GET\"] The method to use in the\n   *     request.\n   * @param  {Body}    [request.body]      The request body.\n   * @param  {Object}  [request.headers={}] The request headers.\n   * @param  {Object}  [options={}]        The options object.\n   * @param  {Boolean} [options.raw=false] If true, resolve with full response\n   * @param  {Boolean} [options.stringify=true] If true, serialize body data to\n   * @param  {Number}  [options.retry=0]   The number of times to\n   *     retry a request if the server responds with Retry-After.\n   * JSON.\n   * @return {Promise<Object, Error>}\n   */\n  async execute<T>(\n    request: KintoRequest,\n    options: {\n      raw?: boolean;\n      stringify?: boolean;\n      retry?: number;\n      query?: { [key: string]: string };\n      fields?: string[];\n    } = {}\n  ): Promise<T | HttpResponse<T>> {\n    const { raw = false, stringify = true } = options;\n    // If we're within a batch, add the request to the stack to send at once.\n    if (this._isBatch) {\n      this._requests.push(request);\n      // Resolve with a message in case people attempt at consuming the result\n      // from within a batch operation.\n      const msg =\n        ((\"This result is generated from within a batch \" +\n          \"operation and should not be consumed.\") as\n          unknown) as\n        T;\n      return raw\n        ? ({ status: 0, json: msg, headers: new Headers() } as HttpResponse<T>)\n        : msg;\n    }\n    const uri = this.remote + addEndpointOptions(request.path, options);\n    const result = await this.http.request<T>(\n      uri,\n      cleanUndefinedProperties({\n        // Limit requests to only those parts that would be allowed in\n        // a batch request -- don't pass through other fancy fetch()\n        // options like integrity, redirect, mode because they will\n        // break on a batch request.  A batch request only allows\n        // headers, method, path (above), and body.\n        method: request.method,\n        headers: request.headers,\n        body: stringify ? JSON.stringify(request.body) : request.body,\n      }),\n      { retry: this._getRetry(options) }\n    );\n    return raw ? result : result.json;\n  }\n\n  /**\n   * Fetch some pages from a paginated list, following the `next-page`\n   * header automatically until we have fetched the requested number\n   * of pages. Return a response with a `.next()` method that can be\n   * called to fetch more results.\n   *\n   * @private\n   * @param  {String}  path\n   *     The path to make the request to.\n   * @param  {Object}  params\n   *     The parameters to use when making the request.\n   * @param  {String}  [params.sort=\"-last_modified\"]\n   *     The sorting order to use when fetching.\n   * @param  {Object}  [params.filters={}]\n   *     The filters to send in the request.\n   * @param  {Number}  [params.limit=undefined]\n   *     The limit to send in the request. Undefined means no limit.\n   * @param  {Number}  [params.pages=undefined]\n   *     The number of pages to fetch. Undefined means one page. Pass\n   *     Infinity to fetch everything.\n   * @param  {String}  [params.since=undefined]\n   *     The ETag from which to start fetching.\n   * @param  {Array}   [params.fields]\n   *     Limit response to just some fields.\n   * @param  {Object}  [options={}]\n   *     Additional request-level parameters to use in all requests.\n   * @param  {Object}  [options.headers={}]\n   *     Headers to use during all requests.\n   * @param  {Number}  [options.retry=0]\n   *     Number of times to retry each request if the server responds\n   *     with Retry-After.\n   */\n  async paginatedList<T>(\n    path: string,\n    params: PaginatedListParams = {},\n    options: { headers?: Record<string, string>; retry?: number } = {}\n  ): Promise<PaginationResult<T>> {\n    // FIXME: this is called even in batch requests, which doesn't\n    // make any sense (since all batch requests get a \"dummy\"\n    // response; see execute() above).\n    const { sort, filters, limit, pages, since, fields } = {\n      sort: \"-last_modified\",\n      ...params,\n    };\n    // Safety/Consistency check on ETag value.\n    if (since && typeof since !== \"string\") {\n      throw new Error(\n        `Invalid value for since (${since}), should be ETag value.`\n      );\n    }\n\n    const query: { [key: string]: any } = {\n      ...filters,\n      _sort: sort,\n      _limit: limit,\n      _since: since,\n    };\n    if (fields) {\n      query._fields = fields;\n    }\n    const querystring = qsify(query);\n    let results: T[] = [],\n      current = 0;\n\n    const next = async function (\n      nextPage: string | null\n    ): Promise<PaginationResult<T>> {\n      if (!nextPage) {\n        throw new Error(\"Pagination exhausted.\");\n      }\n\n      return processNextPage(nextPage);\n    };\n\n    const processNextPage = async (\n      nextPage: string\n    ): Promise<PaginationResult<T>> => {\n      const { headers } = options;\n      return handleResponse(await this.http.request(nextPage, { headers }));\n    };\n\n    const pageResults = (\n      results: T[],\n      nextPage: string | null,\n      etag: string | null\n    ): PaginationResult<T> => {\n      // ETag string is supposed to be opaque and stored as-is.\n      // ETag header values are quoted (because of * and W/\"foo\").\n      return {\n        last_modified: etag ? etag.replace(/\"/g, \"\") : etag,\n        data: results,\n        next: next.bind(null, nextPage),\n        hasNextPage: !!nextPage,\n        totalRecords: -1,\n      };\n    };\n\n    const handleResponse = async function ({\n      headers,\n      json,\n    }: HttpResponse<DataResponse<T[]>>): Promise<PaginationResult<T>> {\n      const nextPage = headers.get(\"Next-Page\");\n      const etag = headers.get(\"ETag\");\n\n      if (!pages) {\n        return pageResults(json.data, nextPage, etag);\n      }\n      // Aggregate new results with previous ones\n      results = results.concat(json.data);\n      current += 1;\n      if (current >= pages || !nextPage) {\n        // Pagination exhausted\n        return pageResults(results, nextPage, etag);\n      }\n      // Follow next page\n      return processNextPage(nextPage);\n    };\n\n    return handleResponse(\n      (await this.execute(\n        // N.B.: This doesn't use _getHeaders, because all calls to\n        // `paginatedList` are assumed to come from calls that already\n        // have headers merged at e.g. the bucket or collection level.\n        {\n          headers: options.headers ? options.headers : {},\n          path: path + \"?\" + querystring,\n        },\n        // N.B. This doesn't use _getRetry, because all calls to\n        // `paginatedList` are assumed to come from calls that already\n        // used `_getRetry` at e.g. the bucket or collection level.\n        { raw: true, retry: options.retry || 0 }\n      )) as HttpResponse<DataResponse<T[]>>\n    );\n  }\n\n  /**\n   * Lists all permissions.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers={}] Headers to use when making\n   *     this request.\n   * @param  {Number} [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object[], Error>}\n   */\n  @capable([\"permissions_endpoint\"])\n  async listPermissions(\n    options: PaginatedListParams & {\n      retry?: number;\n      headers?: Record<string, string>;\n    } = {}\n  ): Promise<PaginationResult<PermissionData>> {\n    const path = endpoints.permissions();\n    // Ensure the default sort parameter is something that exists in permissions\n    // entries, as `last_modified` doesn't; here, we pick \"id\".\n    const paginationOptions = { sort: \"id\", ...options };\n    return this.paginatedList<PermissionData>(path, paginationOptions, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Retrieves the list of buckets.\n   *\n   * @param  {Object} [options={}]      The options object.\n   * @param  {Object} [options.headers={}] Headers to use when making\n   *     this request.\n   * @param  {Number} [options.retry=0]    Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Object} [options.filters={}] The filters object.\n   * @param  {Array}  [options.fields]     Limit response to\n   *     just some fields.\n   * @return {Promise<Object[], Error>}\n   */\n  async listBuckets(\n    options: PaginatedListParams & {\n      retry?: number;\n      headers?: Record<string, string>;\n      filters?: Record<string, string | number>;\n      fields?: string[];\n      since?: string;\n    } = {}\n  ): Promise<PaginationResult<KintoObject>> {\n    const path = endpoints.bucket();\n    return this.paginatedList<KintoObject>(path, options, {\n      headers: this._getHeaders(options),\n      retry: this._getRetry(options),\n    });\n  }\n\n  /**\n   * Creates a new bucket on the server.\n   *\n   * @param  {String|null}  id                The bucket name (optional).\n   * @param  {Object}       [options={}]      The options object.\n   * @param  {Boolean}      [options.data]    The bucket data option.\n   * @param  {Boolean}      [options.safe]    The safe option.\n   * @param  {Object}       [options.headers] The headers object option.\n   * @param  {Number}       [options.retry=0] Number of retries to make\n   *     when faced with transient errors.\n   * @return {Promise<Object, Error>}\n   */\n  async createBucket<T extends MappableObject>(\n    id: string | null,\n    options: {\n      data?: T & { id?: string };\n      permissions?: Partial<Record<Permission, string[]>>;\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n    } = {}\n  ): Promise<KintoResponse<T>> {\n    const { data, permissions } = options;\n    const _data = { ...data, id: id ? id : undefined };\n    const path = _data.id ? endpoints.bucket(_data.id) : endpoints.bucket();\n    return (\n      this.execute<KintoResponse<T>>(\n        requests.createRequest(\n          path,\n          { data: _data, permissions },\n          {\n            headers: this._getHeaders(options),\n            safe: this._getSafe(options),\n          }\n        ),\n        { retry: this._getRetry(options) }\n      ) as Promise<KintoResponse<T>>\n    );\n  }\n\n  /**\n   * Deletes a bucket from the server.\n   *\n   * @ignore\n   * @param  {Object|String} bucket                  The bucket to delete.\n   * @param  {Object}        [options={}]            The options object.\n   * @param  {Boolean}       [options.safe]          The safe option.\n   * @param  {Object}        [options.headers]       The headers object option.\n   * @param  {Number}        [options.retry=0]       Number of retries to make\n   *     when faced with transient errors.\n   * @param  {Number}        [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  async deleteBucket(\n    bucket: string | KintoIdObject,\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{ deleted: boolean }>> {\n    const bucketObj = toDataBody(bucket);\n    if (!bucketObj.id) {\n      throw new Error(\"A bucket id is required.\");\n    }\n    const path = endpoints.bucket(bucketObj.id);\n    const { last_modified } = { ...bucketObj, ...options };\n    return (\n      this.execute<KintoResponse<{ deleted: boolean }>>(\n        requests.deleteRequest(path, {\n          last_modified,\n          headers: this._getHeaders(options),\n          safe: this._getSafe(options),\n        }),\n        { retry: this._getRetry(options) }\n      ) as Promise<KintoResponse<{ deleted: boolean }>>\n    );\n  }\n\n  /**\n   * Deletes all buckets on the server.\n   *\n   * @ignore\n   * @param  {Object}  [options={}]            The options object.\n   * @param  {Boolean} [options.safe]          The safe option.\n   * @param  {Object}  [options.headers]       The headers object option.\n   * @param  {Number}  [options.last_modified] The last_modified option.\n   * @return {Promise<Object, Error>}\n   */\n  @support(\"1.4\", \"2.0\")\n  async deleteBuckets(\n    options: {\n      safe?: boolean;\n      headers?: Record<string, string>;\n      retry?: number;\n      last_modified?: number;\n    } = {}\n  ): Promise<KintoResponse<{ deleted: boolean }>> {\n    const path = endpoints.bucket();\n    return (\n      this.execute<KintoResponse<{ deleted: boolean }>>(\n        requests.deleteRequest(path, {\n          last_modified: options.last_modified,\n          headers: this._getHeaders(options),\n          safe: this._getSafe(options),\n        }),\n        { retry: this._getRetry(options) }\n      ) as Promise<KintoResponse<{ deleted: boolean }>>\n    );\n  }\n\n  @capable([\"accounts\"])\n  async createAccount(\n    username: string,\n    password: string\n  ): Promise<KintoResponse<{ password: string }>> {\n    return (\n      this.execute<KintoResponse<{ password: string }>>(\n        requests.createRequest(\n          `/accounts/${username}`,\n          { data: { password } },\n          { method: \"PUT\" }\n        )\n      ) as Promise<KintoResponse<{ password: string }>>\n    );\n  }\n}\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__decorate","decorators","target","key","desc","c","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","__generator","body","f","y","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","v","op","TypeError","pop","push","__values","o","m","__read","ar","error","toDataBody","resource","isObject","id","Error","qsify","obj","encode","encodeURIComponent","String","stripped","cleanUndefinedProperties","keys","map","k","ks","isArray","join","checkVersion","version","minVersion","maxVersion","extract","str","split","x","parseInt","_a","verMajor","verMinor","_b","minMajor","minMinor","_c","maxMajor","maxMinor","some","capable","capabilities","descriptor","fn","configurable","get","wrappedMethod","_i","args","client","_this","fetchServerCapabilities","available","missing","filter","missingStr","writable","nobatch","message","_isBatch","thing","extractFileInfo","dataURL","match","substr","props","base64","type","params","reduce","acc","param","name","binary","atob","array","charCodeAt","blob","Blob","Uint8Array","obscureAuthorizationHeader","headers","h","Headers","has","set","obscuredHeaders","entries","_d","header","ERROR_CODES","104","105","106","107","108","109","110","111","112","113","114","115","116","117","121","122","201","202","999","url","options","_super","JSON","stringify","captureStackTrace","NetworkTimeoutError","response","status","UnparseableResponseError","stack","json","errnoMsg","statusText","errno","trim","ServerResponse","data","events","requestMode","HTTP","defaultOptions","timeout","Accept","Content-Type","hasTimedout","_timeoutId","proceedWithHandler","arg","clearTimeout","setTimeout","fetch","catch","text","parse","err","retryAfter","request","ms","retry","DEFAULT_REQUEST_HEADERS","FormData","delete","mode","timedFetch","_checkForDeprecationHeader","_checkForBackoffHeader","_checkForRetryAfterHeader","processResponse","alertHeader","alert","console","warn","emit","backoffMs","backoffHeader","backoffSeconds","Date","getTime","delay","tryAgainAfter","ENDPOINTS","root","batch","permissions","bucket","history","collection","coll","group","record","attachment","requestDefaults","safe","patch","safeHeader","last_modified","If-Match","If-None-Match","createRequest","path","method","updateRequest","undefined","jsonPatchPermissionsRequest","opType","_f","principals","principals_1","principal","deleteRequest","addAttachmentRequest","dataURI","gzipped","formData","filename","property","append","createFormData","aggregate","responses","requests","index","published","extracts","skipped","conflicts","local","remote","details","existing","errors","getRandomValues","crypto","bind","msCrypto","rnds8","rng","byteToHex","toString","v4","buf","offset","rnds","random","ii","bth","bytesToUuid","_endpoints","endpoints","_retry","_safe","_headers","Collection","_getHeaders","execute","raw","_getRetry","query","fields","requests.updateRequest","_getSafe","requests.jsonPatchPermissionsRequest","requests.createRequest","uuid","requests.addAttachmentRequest","getRecord","recordId","requests.deleteRequest","recordObj","at","getSnapshot","paginatedList","listHistory","limit","filters","action","resource_name","collection_id","isHistoryComplete","pages","Infinity","sort","max_target.data.last_modified","Number","isInteger","listChangesBackTo","changes","seenIds","Set","snapshot","add","changes_1","a","hasNextPage","totalRecords","Bucket","bucketId","collectionObj","members","groupObj","slice","_backoffReleaseTime","_requests","serverInfo","http","_registerHTTPEvents","min","max","KintoClientBase","_remote","_version","currentTime","on","_getHello","fetchServerInfo","fetchServerSettings","serverSettings","maxRequests","chunks","results","chunks_1","chunk","_batchRequests","concat","defaults","rootBatch","msg","uri","_fields","queryString","addEndpointOptions","since","_sort","_limit","_since","querystring","current","nextPage","processNextPage","handleResponse","pageResults","etag","replace","paginationOptions","_data","bucketObj","username","password","fetchHTTPApiVersion"],"mappings":"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"}